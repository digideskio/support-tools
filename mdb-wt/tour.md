# WT storage model for MongoDB by example

This document presents a tour by example of the WiredTiger storage
format as used by MongoDB.

&emsp;&emsp;1 [Record-store btree mode](#1)  
&emsp;&emsp;&emsp;&emsp;1.1 [Collection data](#1.1)  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.1.1 [Collection btree leaf node page](#1.1.1)  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.1.2 [Collection btree internal node page](#1.1.2)  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.1.3 [Block manager page and extent list](#1.1.3)  
&emsp;&emsp;&emsp;&emsp;1.2 [The _id index](#1.2)  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.2.4 [_id index btree leaf node page](#1.2.4)  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.2.5 [_id index internal node page](#1.2.5)  
&emsp;&emsp;&emsp;&emsp;1.3 [Another index example](#1.3)  
&emsp;&emsp;&emsp;&emsp;1.4 [Comparison of WT and mmapv1 btrees](#1.4)  
&emsp;&emsp;&emsp;&emsp;1.5 [Data updates](#1.5)  
&emsp;&emsp;2 [LSM mode](#2)  
&emsp;&emsp;3 [Metadata files](#3)  
&emsp;&emsp;4 [Durability](#4)  
&emsp;&emsp;5 [Checksums and compression](#5)  

**NOTE**: this is a work-in-progress and probably
contains errors as I'm writing this as I learn about WT. Please
contact me if you spot anything incorrect or questionable, or if you
have answers to any of the questions!

The examples in this document were generated by running the code and
then using
[mdb-wt](https://github.com/10gen/support-tools/tree/master/mdb-wt), a
WT version of the
[mdb](https://github.com/10gen/support-tools/tree/master/mdb) MongoDB
db dump utility.

## <a name="1"></a> 1 Record-store btree mode

The default mode for storing collections and index is record-store
btrees. This is illustrated in the following sections by a simple
example: <a name="example1"></a>

    db.c.ensureIndex({hello:1, "here's a number field":1})
    for (var i=0; i<1000; i++)
        db.c.insert({hello: 'world', "here's a number field": 12345+i})

In record-store btree mode this code creates the following files that
contain the collection and index data:

    collection-$n-$x.wt    stores data for a single collection
    index-$n-$x.wt         stores an index

Each filename follows a pattern as described above, encoding the following information:

* $n is a collection or index number, starting at 1 and incrementing
  by 1 for each collection or index
* $x **TBD**

Note that unlike mmapv1

* there is a separate file for each collection; databases play no role
  in the division of data into files.
* the db name is not encoded in the filename. The mapping from
  namespaces to filenames is maintained in a separate metadata
  collection file, \_mdb\_catalog.wt, described in a
  [later section](#metadata-files)).

**TBD**: meaning of fields of collection and index filenames.

**TBD** file size limits? multiple files for a single collection?

### <a name="1.1"></a> 1.1 Collection data

Collection data in record-store btree mode is stored in a
collection-\*.wt file. The file begins with a 4KB descriptor page,
containing only basic file information in the first few bytes:

    00000000: block_desc magic=120897(OK) major=1 minor=0 cksum=b72308d8

This is followed by a sequence of _pages_. Each page is aligned to a
4KB boundary and is a multiple of 4KB in length.

#### <a name="1.1.1"></a> 1.1.1 Collection btree leaf node page

The first page, at file offset 0x1000 (4KB) and length 0x6000 (24KB),
is a btree leaf node that contains collection data:

    00001000: page recno=0 gen=1 msz=0x5fb6 entries=654 type=7(ROW_LEAF) flags=0x4(no0)
    0000101c: block sz=0x6000 cksum=0x9288bb5a flags=0x1(cksum)
    00001028:   key desc=0x5(short) sz=1 key=pack(1)
    0000102a:   val desc=0x80(long) sz=70
    00001030:     DOC len=70
    00001031:       '_id': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 be =2014-11-09T13:52:34Z
    00001042:       'hello': string len=6 strlen=5 ='world'
    00001053:       "here's a number field": double 00 00 00 00 80 1c c8 40 =12345
    00001072:     EOO
    00001072:   key desc=0x5(short) sz=1 key=pack(2)
    00001074:   val desc=0x80(long) sz=70
    0000107a:     DOC len=70
    0000107b:       '_id': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 bf =2014-11-09T13:52:34Z
    0000108c:       'hello': string len=6 strlen=5 ='world'
    0000109d:       "here's a number field": double 00 00 00 00 00 1d c8 40 =12346
    000010bc:     EOO
    000010bc:   key desc=0x5(short) sz=1 key=pack(3)
    000010be:   val desc=0x80(long) sz=70
    000010c4:     DOC len=70
    000010c5:       '_id': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 c0 =2014-11-09T13:52:34Z
    000010d6:       'hello': string len=6 strlen=5 ='world'
    000010e7:       "here's a number field": double 00 00 00 00 80 1d c8 40 =12347
    00001106:     EOO
    ...

The page begins with a header. (Technically, two headers, a page
header and a block header, contributed by different software modules,
but the net effect is a single page header.) Important fields are:

* number of entries on the page. Each entry is a key or a value.
* page type identifying this page as a leaf btree node in a record store.
* a checksum to detect file corruption.

This is followed by a sequence of key/value pairs, sorted by
key. Since this is a leaf node of a btree representing a MongoDB
collection,

* the key is an integer record id (stored as a packed int).
* the value is a BSON document which is the content of the record.

Note that unlike mmapv1, wt btrees are used for storing collection
data as well as for storing indexes.

**TBD** maximum value sizes? overflow?

**TBD** check terminology for "record id"


#### <a name="1.1.2"></a> 1.1.2 Collection btree internal node page

For this example the file continues with three more leaf node pages
for a total of four. This is then followed by an intenal btree node
page (which happens to be the root):

    00014000: page recno=0 gen=5 msz=0x57 entries=8 type=6(ROW_INT) flags=0x0()
    0001401c: block sz=0x1000 cksum=0x18eec00f flags=0x1(cksum)
    00014028:   key desc=0x5(short) sz=1 key='\x00'
    0001402a:   val desc=0x30 sz=7 addr=0,6,0x9288bb5a
    00014033:   key desc=0x9(short) sz=2 key=pack(328)
    00014036:   val desc=0x30 sz=7 addr=6,6,0x94c4fe0c
    0001403f:   key desc=0x9(short) sz=2 key=pack(655)
    00014042:   val desc=0x30 sz=7 addr=12,6,0x709db86
    0001404b:   key desc=0x9(short) sz=2 key=pack(982)
    0001404e:   val desc=0x30 sz=7 addr=18,1,0x854a24ed

Like leaf node pages this page contains a sequence of key/value
pairs. For internal nodes:

* The key is a record id that is less than or equal to the first key
  for the child page and greater than the last key on the previous
  child page. (**TBD**: check this)

* The value is an _address token_ <a name="address-token"></a>
  (**TBD** check terminology) referencing the child page, stored as a
  triple of packed ints:
    * first element appears to be page offset / 4KB - 1 (**TBD** check
      this)
    * second element appears to be page length / 4KB (**TBD** check
      this)
    * third element is checksum of referenced page

Note that unlike mmpav1 btrees, WT btrees

* are used for both collection data and indexes, and
* do not store values as such in the internal nodes, only keys and
  references to other nodes. This keeps the internal nodes compact,
  even when storing collection data.

**TBD** is the root always last, or is it identified in some other way?


#### <a name="1.1.3"></a> 1.1.3 Block manager page and extent list

The file ends with a block manager page that contains a list of
extents within this file:

    00015000: page recno=0 gen=0 msz=52(34) entries=12 type=1(BLOCK_MANAGER) flags=0()
    0001501c: block sz=4096 cksum=d228e642 flags=1(cksum)
    0001502c:   magic=71002(OK) zero=0
    00015032:   off=1000 sz=14000
    00015034:   off=0 sz=0

Each entry in the list is stored as a pair of packed ints. The list
begins and ends with sentinal entries. In this example there is a
single extent starting at offset 0x1000 (4KB) of size 0x14000 (20KB).

**TBD** unused extents?

**TBD** can this be larger than 4KB?

**TBD** file size limits?

### <a name="1.2"></a> 1.2 The _id index

Indexes are stored in an index-\*.wt file. In this example, the _id
index happens to be stored in the index-3-\*.wt file. This file has
the same overall structure as a collection-\*.wt file, so the file
begins with the same 4KB header containing basic file information:

    00000000: block_desc magic=120897(OK) major=1 minor=0 cksum=0xb72308d8

#### <a name="1.2.4"></a> 1.2.4 _id index btree leaf node page

This is again followed by a sequence of pages. The first page is a
btree leaf node:

    00001000: page recno=0 gen=1 msz=0x2ff6 entries=844 type=7(ROW_LEAF) flags=0x4(no0)
    0000101c: block sz=0x3000 cksum=0x144012c9 flags=0x1(cksum)
    00001028:   key desc=0x4d(short) sz=19
    0000102d:     DOC len=19
    0000102e:       '': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 be =2014-11-09T13:52:34Z
    0000103c:     EOO
    0000103c:   val desc=0x23(short) sz=8 val=00 00 00 00 01 00 00 00
    00001045:   key desc=0x4d(short) sz=19
    0000104a:     DOC len=19
    0000104b:       '': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 bf =2014-11-09T13:52:34Z
    00001059:     EOO
    00001059:   val desc=0x23(short) sz=8 val=00 00 00 00 02 00 00 00
    00001062:   key desc=0x4d(short) sz=19
    00001067:     DOC len=19
    00001068:       '': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 42 c0 =2014-11-09T13:52:34Z
    00001076:     EOO
    ...

The leaf node contains a sequence of key/value pairs (844/2 pairs in this case), where:

* The bree key is a BSON document containing fields whose names are
  the empty string, and whose values are the fields of the MongoDB
  key. In this case the _id index has keys with only one value, an
  objectid.
* The value is an 8-byte record id, which are the keys in the
  collection btree. (**TBD** exact format)

#### <a name="1.2.5"></a> 1.2.5 _id index internal node page

Here is the root node for the _id index:

    00009000: page recno=0 gen=4 msz=0x6d entries=6 type=6(ROW_INT) flags=0x0()
    0000901c: block sz=0x1000 cksum=0xb0e85b9d flags=0x1(cksum)
    00009028:   key desc=0x5(short) sz=1
    00009029:     00
    0000902a:   val desc=0x30 sz=7 addr=0,3,0x144012c9
    00009033:   key desc=0x4d(short) sz=19
    00009038:     DOC len=19
    00009039:       '': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 44 64 =2014-11-09T13:52:34Z
    00009047:     EOO
    00009047:   val desc=0x30 sz=7 addr=3,3,0x6aa87779
    00009050:   key desc=0x4d(short) sz=19
    00009055:     DOC len=19
    00009056:       '': objectid 54 5f 71 a2 fc a1 e4 46 8a 93 46 0a =2014-11-09T13:52:34Z
    00009064:     EOO
    00009064:   val desc=0x30 sz=7 addr=6,2,0x1b930774

This is a list of key/value pairs where

* The btree key is a BSON document containing fields whose names are
  the empty string, and whose values are the fields of the MongoDB
  key. In this case the _id index has keys with only one value, an
  objectid.  The key is less than or equal to the first key for the
  child page and greater than the last key on the previous child
  page. (**TBD**: check this)
* As with collection internal nodes, the value is an [address
  token](#address-token) (**TBD** check terminology) referencing the
  child page.

### <a name="1.3"></a> 1.3 Another index example

[Our example](#example1) created a second index with key {hello:1,
"here's a number field":1}. In this case this index happens to be
stored in the index-4-\*.wt file. Here's a btree leaf node for that
index:

    00001000: page recno=0 gen=1 msz=0x2ff8 entries=340 type=7(ROW_LEAF) flags=0x2(all0)
    0000101c: block sz=0x3000 cksum=0xda402a95 flags=0x1(cksum)
    00001028:   key desc=0x8d(short) sz=35
    0000102d:     DOC len=27
    0000102e:       '': string len=6 strlen=5 ='world'
    0000103a:       '': double 00 00 00 00 80 1c c8 40 =12345
    00001044:     EOO
    00001044:     00 00 00 00 01 00 00 00
    0000104c:   key desc=0x8d(short) sz=35
    00001051:     DOC len=27
    00001052:       '': string len=6 strlen=5 ='world'
    0000105e:       '': double 00 00 00 00 00 1d c8 40 =12346
    00001068:     EOO
    00001068:     00 00 00 00 02 00 00 00
    00001070:   key desc=0x8d(short) sz=35
    00001075:     DOC len=27
    00001076:       '': string len=6 strlen=5 ='world'
    00001082:       '': double 00 00 00 00 80 1d c8 40 =12347
    0000108c:     EOO
    0000108c:     00 00 00 00 03 00 00 00
    ...

Note that this node contains only keys, and no values. Each btree key
is the concatenation of

* a BSON document containing fields whose names are the empty string,
  and whose values are the fields of the MongoDB key (a string and a
  double in this case), and
* an 8-byte record id (**TBD exact format**)

Thus, whereas the _id index stores the record id as the value of a
key/value pair, this index stores the record id as part of the key,
and has no values.

**TBD** to make keys unique since this isn't a unique index? what
about non-\_id unique indexes? why not just do _id index the same way?
Because it allows for more efficient retrieval in the case of a unique
key?
    
### <a name="1.4"></a> 1.4 Comparison of WT and mmapv1 btrees

The following table summarizes the differences between mmapv1 and WT
btrees, showing the content for each item in a btree node.

|               | mmapv1 index                       | WT index                      | WT collection                   |
|---------------|------------------------------------|-------------------------------|---------------------------------|
| internal node | key, diskloc, btree node reference | key, btree node reference     | record id, btree node reference |
| leaf node     | key, diskloc, null node reference  | key, record id; _or_ key only | record id, BSON document        |

### <a name="1.5"></a> 1.5 Data updates

Suppose we now update one of our records, for example:

    db.c.update({"here's a number field": 12350}, {'now': "it's smaller"})

With mmapv1, since this update has not made the document larger, the
update would have been done in-place. However WT handles this
differently. Here is a comparison of the state of the collection file
before and after this update:

              BEFORE                               AFTER
    00001000: page entries=654 typeROW_LEAF        UNUSED
    00007000: page entries=654 type=ROW_LEAF       page entries=654 type=ROW_LEAF
    0000d000: page entries=654 type=ROW_LEAF       page entries=654 type=ROW_LEAF
    00013000: page entries=38 type=ROW_LEAF        page entries=38 type=ROW_LEAF                
    00014000: page entries=8 typeROW_INT           UNUSED
    00015000: page entries=12 type=BLOCK_MANAGER   UNUSED
    00016000:                                      page entries=654 type=ROW_LEAF
    0001c000:                                      page entries=8 type=ROW_INT
    0001d000:                                      page entries=19 type=BLOCK_MANAGER
    0001e000:                                      page entries=17 type=BLOCK_MANAGER

* The update requires updating a record contained in the btree leaf
  node that was stored in the page at 0x1000 before the update.  The
  modified leaf node is written to the end of the file at
  0x16000. This new leaf node is fully compacted; that is, the space
  allocated for the now-smaller document is just exactly enough to
  hold the document.  The original version is left in place at 0x1000,
  but will be marked as unused in the block manager record.

* Since the modified leaf node has been moved, the root node at
  0x14000 that points to the leaf node must be modified to point to
  the new location. The modified root node is written to the end of
  the file at 0x1c000.  The original version is left in place at
  0x14000, but will be marked as unused in the block manager record.

* Since the used/unused extents have changed, the block manager record
  needs to change. Two new block manager records are written to the
  end of the file, recording used and unused extents respectively.
  The previous block manager record at 0x15000 is left in place, but
  is marked unused in the new block manager records.

Here are the two new block manager records at the end of the file. The
first records the two in-use extents at 0x7000 and 0x16000:

    0001d000: page recno=0 gen=0 msz=0x3b entries=19 type=1(BLOCK_MANAGER) flags=0x0()
    0001d01c: block sz=0x1000 cksum=0x79ea689c flags=0x1(cksum)
    0001d02c:   magic=71002(OK) zero=0
    0001d032:   off=0x7000 sz=0xd000
    0001d039:   off=0x16000 sz=0x7000
    0001d03b:   off=0x0 sz=0x0

The second block manager record records the two unused extents at
0x1000 and 0x14000:

    0001e000: page recno=0 gen=0 msz=0x39 entries=17 type=1(BLOCK_MANAGER) flags=0x0()
    0001e01c: block sz=0x1000 cksum=0x342ada60 flags=0x1(cksum)
    0001e02c:   magic=71002(OK) zero=0
    0001e031:   off=0x1000 sz=0x6000
    0001e037:   off=0x14000 sz=0x2000
    0001e039:   off=0x0 sz=0x0

Now suppose we modify another leaf node, say by inserting a new document:

    db.c.insert({'this is': 'new'})

Here is a comparison of the state of the collection file
before and after this update:

              BEFORE                               AFTER
    00001000: UNUSED                               page entries=19 type=BLOCK_MANAGER
    00002000: UNUSED                               page entries=24 type=BLOCK_MANAGER
    00003000  UNUSED                               UNUSED    
    00007000: page entries=654 type=ROW_LEAF       page entries=654 type=ROW_LEAF
    0000d000: page entries=654 type=ROW_LEAF       page entries=654 type=ROW_LEAF
    00013000: page entries=38 type=ROW_LEAF        UNUSED
    00014000: UNUSED                               page entries=40 type=ROW_LEAF
    00015000: UNUSED                               page entries=8 type=ROW_INT
    00016000: page entries=654 type=ROW_LEAF       page entries=654 type=ROW_LEAF
    0001c000: page entries=8 type=ROW_INT          UNUSED
    0001d000: page entries=19 type=BLOCK_MANAGER   UNUSED
    0001e000: page entries=17 type=BLOCK_MANAGER   UNUSED

* The inserted record gets the next sequential record id, so the
  record goes into the last leaf node at 0x13000, increasing entries
  from 38 to 40 (one for key, one for value). The modified page for
  that leaf node is written to an unused location at 0x14000, and the
  previous version at 0x13000 is marked unused in the block manager
  record.

* Since the modified leaf node has a new location on disk, the root
  node at 0x1c000 that points to it must be modified. The new version
  of the root node is written to an unused location at 0x15000, and
  the previous version at 0x1c000 is marked unused in the block
  manager record.

* The new block manager records recording the new used and unused
  extents are written to unused locations at 0x1000 and 0x2000. The
  previous block manager records at 0x1d000 and 0x1e000 are marked
  unused.

Here are the new block manager records recording the unused and used
extents respectively:

    00001000: page recno=0 gen=0 msz=0x3b entries=19 type=1(BLOCK_MANAGER) flags=0x0()
    0000101c: block sz=0x1000 cksum=0xaf5837ab flags=0x1(cksum)
    0000102c:   magic=71002(OK) zero=0
    00001032:   off=0x7000 sz=0xc000
    00001039:   off=0x14000 sz=0x8000
    0000103b:   off=0x0 sz=0x0
    
    00002000: page recno=0 gen=0 msz=0x40 entries=24 type=1(BLOCK_MANAGER) flags=0x0()
    0000201c: block sz=0x1000 cksum=0xde8d1827 flags=0x1(cksum)
    0000202c:   magic=71002(OK) zero=0
    00002031:   off=0x2000 sz=0x5000
    00002037:   off=0x13000 sz=0x1000
    0000203e:   off=0x1c000 sz=0x3000
    00002040:   off=0x0 sz=0x0

* **TBD** This was done by executing each step, stopping mongod, and looking
  at the data files. Presumably this forces a checkpoint. Is the
  situation any different if the data files are flushed for any other
  reason, or different for checkpoints other than the one on shutdown?

* **TBD** Are the examples shown here representative of typical behavior?
    * is it true that records are never updated in place?
    * is it always the case that when a page is changed, even if the
       page does not grow, it will not be re-written in place, but
       rather written to a currently unused extent, and the current
       location then marked as unused?
           
* **TBD** Oddly, the new block manager page at 2000 after the last
    update above lists itself as being unused (if I'm interpreting
    things correctly). What's up hat?

* **TBD** Since it appears that the location of the page manager pages
  detailing the extents can move, how are they found?

## <a name="2"></a> 2 LSM mode

In LSM mode the data is stored in files in the same btree format as
record-store mode; the difference is how updates to those files are
managed. The file naming scheme for LSM mode is as follows:

    collection-$n-$x-$seq.lsm    stores data for a single collection
    index-$n-$x-$seq.lsm         stores an index

Each filename follows a pattern as described above, encoding the following information:

* $n is a collection or index number, starting at 1 and incrementing
  by 1 for each collection or index
* $x **TBD**
* $seq **TBD** sequence number (*TBD* terminology?)


## <a name="3"></a> 3 Metadata files

<a name="metadata-files"></a>

    _mdb_catalog.*    TBD
    sizeStorer.*      TBD

The \_mdb\_catalog file is a collection containing metadata about
collections and indexes. For example here is the entry in \_mdb\_catalog
related to our example collection:

    00001000: page recno=0 gen=1 msz=0x3a0 entries=4 type=7(ROW_LEAF) flags=0x4(no0)
    0000101c: block sz=0x1000 cksum=0xd8d426c1 flags=0x1(cksum)
    ...
    00001182:   key desc=0x5(short) sz=1 key=pack(2)
    00001184:   val desc=0x80(long) sz=537
    0000118b:     DOC len=537
    0000118c:       'md': DOC len=0x15c(348) EOO=0x12ea
    00001194:         'ns': string len=7 strlen=6 ='test.c'
    000011a3:         'options': DOC len=0x5(5) EOO=0x11af
    000011b0:         EOO
    000011b1:         'indexes': DOC len=0x131(305) EOO=0x12e9
    000011be:           '0': DOC len=0x73(115) EOO=0x1232
    000011c5:             'spec': DOC len=0x3d(61) EOO=0x1206
    000011cf:               'v': int32 01 00 00 00
    000011d6:               'key': DOC len=0xe(14) EOO=0x11e7
    000011df:                 '_id': int32 01 00 00 00
    000011e8:               EOO
    000011e9:               'name': string len=5 strlen=4 ='_id_'
    000011f8:               'ns': string len=7 strlen=6 ='test.c'
    00001207:             EOO
    00001208:             'ready': boolean 01
    00001210:             'multikey': boolean 00
    0000121b:             'head_a': int32 ff ff ff ff
    00001227:             'head_b': int32 00 00 00 00
    00001233:           EOO
    00001234:           '1': DOC len=0xb3(179) EOO=0x12e8
    0000123b:             'spec': DOC len=0x7d(125) EOO=0x12bc
    00001245:               'v': int32 01 00 00 00
    0000124c:               'key': DOC len=0x33(51) EOO=0x1282
    00001255:                 'hello': double 00 00 00 00 00 00 f0 3f =1
    00001264:                 "here's a number field": double 00 00 00 00 00 00 f0 3f =1
    00001283:               EOO
    00001284:               'name': string len=32 strlen=31 ="hello_1_here's a number field_1"
    000012ae:               'ns': string len=7 strlen=6 ='test.c'
    000012bd:             EOO
    000012be:             'ready': boolean 01
    000012c6:             'multikey': boolean 00
    000012d1:             'head_a': int32 ff ff ff ff
    000012dd:             'head_b': int32 00 00 00 00
    000012e9:           EOO
    000012ea:         EOO
    000012eb:       EOO
    000012ec:       'idxIdent': DOC len=0x6e(110) EOO=0x1362
    000012fa:         '_id_': string len=29 strlen=28 ='index-3--8114685204076478674'
    00001321:         "hello_1_here's a number field_1": string len=29 strlen=28 ='index-4--8114685204076478674'
    00001363:       EOO
    00001364:       'ns': string len=7 strlen=6 ='test.c'
    00001373:       'ident': string len=34 strlen=33 ='collection-2--8114685204076478674'
    000013a0:     EOO
    
**TBD** describe the important fields

## <a name="4"></a> 4 Durability

**TBD** when are checkpoints done?

**TBD** journal file format

## <a name="5"></a> 5 Checksums and compression
